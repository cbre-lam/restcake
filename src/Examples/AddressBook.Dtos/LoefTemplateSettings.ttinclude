<#
	//
	// CONFIG SECTION.  Change these values to be specific to your project.
	//

	// This should be the relative path from this template to your .edmx file
	string inputFile = "../AddressBook.DataAccess/AddressBookEntities.edmx";

	// The namespace where your DTO classes are contained
	string dtoClassNamespace = "RestCake.AddressBook.DataAccess";

	// The namespace where your entity classes are contained
	string entityClassNamespace = "RestCake.AddressBook.DataAccess";
	
	string dalClassName = "AddressBookDal";

	// Whether to include the __type variable as a member of the DTO classes (a string that's the simple name of the class)
	bool includeTypeInfo = false;
	
	// The StripCycles() methods will either assign properties to null to remove cycles, or replace those properties with "stub" objects,
	// that have only their ID property set (along with 2 new properties, __isCycleStub = true, and __pathFromRoot = ".path.from.root.json.object").
	// The stub object represents an object that's already in the object graph somewhere else.  To resolve the stub object to the real object
	// in the graph in js, if your root object that was passed to your service callback was named "person", you could do this:
	// 		var resolvedObject = eval("person" + stubObj.__pathFromRoot);
	// I don't recommend wiring up the cycles in the actual javascript object graph itself, because that will cause JSON.stringify() to throw an error.
	// But if you won't be passing back the whole graph, and just a portion (possibly even removing related child properties from an object), then by all means,
	// do what you think is best.
	//(removing related child properties would be like:  person.address = null;, whereas before, address was a valid AddressDto object)
	bool useStubObjectsForCycles = false;
	
	// TODO: Add options for converting dates to strings, to avoid crappy MS AJAX style dates "\/Date(12345-WTF)\/"
	// Use a string format that is inherently parseable by both javascript and .NET, and that when printed as a string, looks good besides.
	bool datesAsStrings = true;
	
	// If you have lazy loading enabled or not.
	// NOTE: If you are using POCO entities, lazy loading is currently not supported with these templates.
	// I'm not sure how to check if a navigation property has been lazy loaded or not already, with the POCO classes.
	// If you are using the POCO classes, you'll have to disable lazy loading in your model.
	bool modelHasLazyLoading = true;
#>
<#+
	// Note that this (currently) only works for types that have a single PK value.  Composite keys are not supported.
	public string GetKeyType(EntityType entity)
	{
		return entity.KeyMembers[0].TypeUsage.EdmType.Name;
	}
	
	
	public string GetEntitySetName(EdmItemCollection itemCollection, EntityType entity)
	{
		EntityContainer container = itemCollection.GetItems<EntityContainer>().FirstOrDefault();
		string entitySetName = "";
		int numFound = 0;
        foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
			if (entitySet.ElementType == entity)
			{
				entitySetName = entitySet.Name;
				++numFound;
			}
		}
		
		if (numFound == 0)
			throw new Exception("Could not find an entity set for EntityType " + entity.Name);
		if (numFound > 1)
			throw new Exception("Multiple entity sets were found for EntityType " + entity.Name);

		return entitySetName;
	}
#>

