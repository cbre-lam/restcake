<#
	/*
	 * Sam Meacham (www.samscode.com)
	 * Template to auto generate DTO classes based on your entity data model (edmx).
	 */
	
	// To configure the options for this template, edit the DtoTemplateSettings.ttinclude file
	// Don't change this file unless you know what you're doing
	
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ include file="LoefTemplateSettings.ttinclude" #>
<#@ output extension=".cs"#>
<#

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
MetadataTools ef = new MetadataTools(this);
EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
string namespaceName = code.VsNamespaceSuggestion();

EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

#>
using System;
using System.Collections.Generic;

namespace <#= dtoClassNamespace #>
{
	/*
	public static class DtoExtensionMethods
	{
<#
	foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
	{
#>
		/// <summary>
		/// Easily create DTO objects from actual domain entity objects
		/// </summary>
		public static <#=code.Escape(entity)#>[] ToEntities(this IEnumerable<<#=code.Escape(entity)#>Dto> dtos)
		{
			return AutoMapper.Mapper.Map<IEnumerable<<#=code.Escape(entity)#>Dto>, <#=code.Escape(entity)#>[]>(dtos);
		}
		
		public static IEnumerable<<#=code.Escape(entity)#>Dto> StripCycles(this IEnumerable<<#=code.Escape(entity)#>Dto> dtos)
		{
			foreach(<#=code.Escape(entity)#>Dto dto in dtos)
				dto.StripCycles();
			return dtos;
		}


		public static <#=code.Escape(entity)#> ToEntity(this <#=code.Escape(entity)#>Dto dto)
		{
			return AutoMapper.Mapper.Map<<#=code.Escape(entity)#>Dto, <#=code.Escape(entity)#>>(dto);
		}
		
<#
	}	
#>
	}
	*/
}

<#


// ********************************************************************************
// *** Emit Entity Types **********************************************************
// ********************************************************************************
foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(entity.Name + "Dto.cs");
    bool entityHasNullableFKs = entity.NavigationProperties.Any(np => np.GetDependentProperties().Any(p=>ef.IsNullable(p)));
#>

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace <#= dtoClassNamespace #>
{

	/// <summary>
	/// TODO: Decide if I want to use FixupCollection{T} classes, with ICollection{T}, or if I just want these to be as plain as possible (manual fixup, etc).
	/// Also, do I want the FK fixup too?  Could be nice...
	/// </summary>
	[DataContract]
	<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#> partial class <#=code.Escape(entity)#>Dto<#=code.StringBefore(" : ", code.Escape(entity.BaseType))#>
	{
		/// <summary>Parameterless constructor (important for serialization)</summary>
		public <#=code.Escape(entity)#>Dto()
		{
<#
		if (useStubObjectsForCycles)
		{
#>
			__isCycleStub = false;
			__pathFromRoot = null;
<#
		}
		
		if (includeTypeInfo)
		{
#>
			__type = "<#=code.Escape(entity)#>";
<#
		}
#>
		}
		
		public <#=code.Escape(entity)#>Dto StripCycles()
		{
			Dictionary<object, string> graphObjs = new Dictionary<object, string>();
			StripCycles(graphObjs, "");
			return this;
		}

<#
		if (useStubObjectsForCycles)
		{
#>
		internal <#=code.Escape(entity)#>Dto GetCycleStub(string pathFromRoot)
		{
			return new <#=code.Escape(entity)#>Dto() { ID = ID, __isCycleStub = true, __pathFromRoot = pathFromRoot };
		}
<#
		}
#>


		internal bool StripCycles(Dictionary<object, string> graphObjs, string path)
		{
			if (graphObjs.ContainsKey(this))
				return false;
			graphObjs.Add(this, path);

<#
    		foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
    		{
        		if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
				{
#>
			// Collections
			if (<#=code.Escape(navProperty)#> != null)
				for(int i = 0; i < <#=code.Escape(navProperty)#>.Count; ++i)
					if (!<#=code.Escape(navProperty)#>[i].StripCycles(graphObjs, path + ".<#=code.Escape(navProperty)#>[" + i + "]"))
<#
					if (useStubObjectsForCycles)
					{
#>
						<#=code.Escape(navProperty)#>[i] = <#=code.Escape(navProperty)#>[i].GetCycleStub(graphObjs[<#=code.Escape(navProperty)#>[i]]);
<#
					}
					else
					{
#>
						// Old way: assigned the ref to null
						//<#=code.Escape(navProperty)#>[i] = null;
						// New way: remove the object completely
						// I know, I know, modifying the indexer is probably bad.  But this was generated from a template.
						// Anyway, for anyone unfamiliar with this, we remove at index i, which is the object that creates a cycle, THEN decrement i,
						// since the "next" object in the list just dropped an index number.  If we didn't decrement i, we'd skip the object after the one we're removing.
						<#=code.Escape(navProperty)#>.RemoveAt(i--);
<#
					}
				}
				else
				{
#>
			// Single navigation property references
			if (<#=code.Escape(navProperty)#> != null)
				if (!<#=code.Escape(navProperty)#>.StripCycles(graphObjs, path + ".<#=code.Escape(navProperty)#>"))
<#
				if (useStubObjectsForCycles)
				{
#>
					<#=code.Escape(navProperty)#> = <#=code.Escape(navProperty)#>.GetCycleStub(graphObjs[<#=code.Escape(navProperty)#>]);
<#
				}
				else
				{
#>
					<#=code.Escape(navProperty)#> = null;
<#					
				}
#>
				

<#
				}
#>
<#
    		} // end of foreach going through each navigation property in the current entity classs
#>
			return true;
		}
		


		// ********************************************************************************
		// *** Primitive properties *******************************************************
		// ********************************************************************************

<#
		if (useStubObjectsForCycles)
		{
#>
		/// <summary>
		/// If true, this is not the original object.  This is a placeholder that only has the ID and FK properties set.
		/// The original object was removed, to prevent cycles in the object graph.
		/// </summary>
		[DataMember] public bool __isCycleStub { get; private set; }

		/// <summary>
		/// 
		/// </summary>
		[DataMember] public string __pathFromRoot { get; private set; }
		
<#
		}
		if (includeTypeInfo)
		{
#>
		[DataMember] public string __type { get; private set; }
		
<#
		}
    foreach (EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity))
    {
        bool isDefaultValueDefinedInModel = (edmProperty.DefaultValue != null);
        bool generateAutomaticProperty = false;
#>
		[DataMember] <#= Accessibility.ForProperty(edmProperty) #> <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#><#
        if (isDefaultValueDefinedInModel)
        {
#>
			<#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
			<#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set { <#=code.FieldName(edmProperty)#> = value; }
<#
        }
        else
        {
            generateAutomaticProperty = true;
#> { get; set; }
<#
        }

        if (!generateAutomaticProperty)
        {
#>
    	private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
<#
        }
    }



#>


		// ********************************************************************************
		// *** Complex properties *********************************************************
		// ********************************************************************************
	
<#
    foreach(EdmProperty edmProperty in entity.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entity))
    {
#>
		[DataMember]
		<#= Accessibility.ForProperty(edmProperty)#> <#=code.Escape(edmProperty.TypeUsage)#>Dto <#=code.Escape(edmProperty)#>
		{
			<#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
			<#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set { <#=code.FieldName(edmProperty)#> = value; }
		}
		private <#=code.Escape(edmProperty.TypeUsage)#>Dto <#=code.FieldName(edmProperty)#> = new <#=code.Escape(edmProperty.TypeUsage)#>Dto();
<#
    }


#>
		// ********************************************************************************
		// *** Navigation properties ******************************************************
		// ********************************************************************************

<#
    foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(np => np.DeclaringType == entity))
    {
        if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
        {
#>
		[DataMember] <#= Accessibility.ForReadOnlyProperty(navProperty) #> List<<#=code.Escape(navProperty.ToEndMember.GetEntityType())#>Dto> <#=code.Escape(navProperty)#> { get; set; }
<#
		}
		else
		{
#>
		[DataMember] <#= Accessibility.ForProperty(navProperty)#> <#=code.Escape(navProperty.ToEndMember.GetEntityType())#>Dto <#=code.Escape(navProperty)#> { get; set; }
<#
		}
#>

<#
    }
#>
	} // end class
} // end namespace

<#

} // end of the outermost foreach going through each entity type



// ********************************************************************************
// *** Create the complex type classes ********************************************
// ********************************************************************************

foreach (ComplexType complex in ItemCollection.GetItems<ComplexType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(complex.Name + ".cs");
#>
using System;
<#
    BeginNamespace(namespaceName, code);
#>

<#=Accessibility.ForType(complex)#> partial class <#=code.Escape(complex)#>
	{
<#
    foreach(EdmProperty edmProperty in complex.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == complex))
    {
        bool isDefaultValueDefinedInModel = (edmProperty.DefaultValue != null);
#>

    	<#=Accessibility.ForProperty(edmProperty)#> <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>
<#
        if (isDefaultValueDefinedInModel)
        {
#>
		{
			<#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
			<#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set { <#=code.FieldName(edmProperty)#> = value; }
		}
		private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#><#=code.StringBefore(" = ", code.CreateLiteral(edmProperty.DefaultValue))#>;
<#
        }
        else
        {
#>
		{
			<#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get;
			<#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set;
		}
<#
        }
    }


	
	
    foreach(EdmProperty edmProperty in complex.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complex))
    {
#>

		<#=Accessibility.ForProperty(edmProperty)#> <#=code.Escape(edmProperty.TypeUsage)#> <#=code.Escape(edmProperty)#>
		{
			<#=code.SpaceAfter(Accessibility.ForGetter(edmProperty))#>get { return <#=code.FieldName(edmProperty)#>; }
			<#=code.SpaceAfter(Accessibility.ForSetter(edmProperty))#>set { <#=code.FieldName(edmProperty)#> = value; }
		}
		private <#=code.Escape(edmProperty.TypeUsage)#> <#=code.FieldName(edmProperty)#> = new <#=code.Escape(edmProperty.TypeUsage)#>();
<#
    }
#>

	} // end class
} // end namespace

<#
}

fileManager.Process();

#>
<#+
void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
{
    fileManager.StartHeader();
#>

<#=String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}


void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}
#>


